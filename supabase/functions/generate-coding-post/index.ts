
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
};

// Time-based helper function to ensure we're not generating posts too frequently
let lastGeneratedTime = 0;

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }
  
  try {
    // Check if this is a scheduled auto-generation request
    const requestData = await req.json().catch(() => ({}));
    const isAutoGenerated = requestData.autoGenerated === true;
    
    // For auto-generated requests, ensure we're not posting too frequently
    if (isAutoGenerated) {
      const currentTime = Date.now();
      const timeSinceLastGeneration = currentTime - lastGeneratedTime;
      
      // Enforce minimum 5 minutes between auto-generated posts
      if (timeSinceLastGeneration < 5 * 60 * 1000) {
        return new Response(JSON.stringify({ 
          skipped: true, 
          message: "Too soon for another post", 
          nextPostIn: 5 * 60 * 1000 - timeSinceLastGeneration 
        }), {
          headers: { ...corsHeaders, "Content-Type": "application/json" },
          status: 200,
        });
      }
      
      lastGeneratedTime = currentTime;
    }
    
    const apiKey = Deno.env.get('PERPLEXITY_API_KEY');
    if (!apiKey) {
      throw new Error('PERPLEXITY_API_KEY is not set in Supabase secrets');
    }

    console.log("Fetching real coding problems from Perplexity API");
    
    // Create a unique query with more randomization factors
    const timestamp = new Date().toISOString();
    const randomSeed = Math.floor(Math.random() * 10000).toString();
    const languages = ["JavaScript", "Python", "React", "TypeScript", "CSS", "HTML", "Node.js", "Vue", "Angular", "Java", "C#", "PHP"];
    const randomLanguage = languages[Math.floor(Math.random() * languages.length)];
    
    // Make query more focused on real developer questions with code issues
    const uniqueQuery = `Find a real coding problem that a developer has posted online about ${randomLanguage}. Current time: ${timestamp}, Random seed: ${randomSeed}. Format it as a casual question like someone would post on Stack Overflow or Reddit - use natural language, informal tone, and include code snippets when relevant. Make it sound like a real human wrote it with a specific coding issue they're trying to solve. Include the programming language as a tag at the end (e.g., @${randomLanguage}). Keep it under 280 characters total.`;
    
    // Use Perplexity API to search for real coding issues on the web
    const response = await fetch('https://api.perplexity.ai/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'llama-3.1-sonar-small-128k-online',
        messages: [
          {
            role: 'system',
            content: 'You are a web crawler that finds real coding questions posted by developers online. When you find a question, rewrite it to sound casual and authentic - like someone quickly typing a forum post. Include some code snippets when appropriate. Make it sound natural and conversational, with some casual words and maybe a few typos. Format the question with ** at the beginning like **HTML issue** or **React problem** to categorize it. Always include a language tag like @JavaScript or @Python at the end of the question. IMPORTANT: Each response must be unique and different from previous ones. Never generate the same content twice. IMPORTANT: If you include code snippets, keep them short (5-10 lines max) and make sure they demonstrate a specific problem the user is having.'
          },
          {
            role: 'user',
            content: uniqueQuery
          }
        ],
        temperature: 1.0,
        max_tokens: 280,
        top_p: 0.95,
        frequency_penalty: 0.9
      }),
    });

    const data = await response.json();
    
    if (!response.ok) {
      console.error("Perplexity API error:", data);
      throw new Error(`Perplexity API returned ${response.status}: ${JSON.stringify(data)}`);
    }
    
    // Verify the content doesn't have repetitive import statements
    let generatedContent = data.choices[0].message.content.trim();
    
    // Check for repetitive import patterns and truncate if necessary
    if (generatedContent.includes('using System.Collections') || 
        generatedContent.includes('import ') || 
        generatedContent.includes('#include')) {
      
      const lines = generatedContent.split('\n');
      let repetitionStartIndex = -1;
      
      // Find where repetition might start
      for (let i = 0; i < lines.length - 1; i++) {
        if (lines[i].trim() === lines[i+1].trim() && lines[i].trim().length > 0) {
          repetitionStartIndex = i;
          break;
        }
      }
      
      // Truncate if repetition found
      if (repetitionStartIndex > 0) {
        generatedContent = lines.slice(0, repetitionStartIndex + 1).join('\n') + 
                          '\n// ... additional imports truncated for brevity';
      }
    }
    
    // Ensure the post has code formatting
    if (!generatedContent.includes('```') && Math.random() > 0.5) {
      // Add code block if missing
      const codeSnippets = {
        "JavaScript": 'document.getElementById("myElement").addEventListener("click", () => {\n  console.log("Why isn\'t this working?");\n});',
        "Python": 'def process_data(items):\n  return [x for x in items if x > 0]\n\nresult = process_data([1, -2, 3])\nprint(result)',
        "HTML": '<div class="container">\n  <button id="btn">Click me</button>\n</div>',
        "CSS": '.my-class {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n}',
        "React": 'const [items, setItems] = useState([]);\nuseEffect(() => {\n  fetchData().then(data => setItems(data));\n}, []);',
        "TypeScript": 'interface User {\n  name: string;\n  age: number;\n}\n\nfunction greet(user: User) {\n  return `Hello ${user.name}`;\n}',
      };
      
      if (randomLanguage in codeSnippets) {
        if (generatedContent.includes("?")) {
          const questionParts = generatedContent.split("?");
          generatedContent = questionParts[0] + "? Here's my code:\n```\n" + codeSnippets[randomLanguage] + "\n```\n" + questionParts.slice(1).join("?");
        } else {
          generatedContent = generatedContent + "\n\n```\n" + codeSnippets[randomLanguage] + "\n```";
        }
      }
    }
    
    console.log("Generated content from real issues:", generatedContent);
    
    // If this is an auto-generated request, also create the post in the database
    if (isAutoGenerated) {
      try {
        // Create a Supabase client
        const supabaseUrl = Deno.env.get('SUPABASE_URL');
        const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');
        
        if (!supabaseUrl || !supabaseKey) {
          throw new Error('Supabase credentials not set in environment variables');
        }
        
        const supabase = await createClient(supabaseUrl, supabaseKey);
        
        const blue5146UserId = '513259a2-555a-4c73-8ce5-db537e33b546';
        const displayUsername = generateRandomUsername();
        
        // Insert post
        const { data: insertedPost, error: insertError } = await supabase
          .from('shoutouts')
          .insert({
            content: generatedContent,
            user_id: blue5146UserId,
            metadata: {
              display_username: displayUsername,
              is_ai_generated: true
            }
          })
          .select('id')
          .single();
          
        if (insertError) {
          throw new Error(`Failed to insert post: ${insertError.message}`);
        }
        
        // Add reactions and comments asynchronously
        if (insertedPost?.id) {
          // Schedule this work in the background
          EdgeRuntime.waitUntil((async () => {
            const commentCount = Math.floor(Math.random() * 26) + 15;
            
            await addAIComments(supabase, insertedPost.id, generatedContent, blue5146UserId, commentCount);
            await addRandomEmojiReactions(supabase, insertedPost.id, blue5146UserId);
            
            console.log(`Successfully added ${commentCount} comments and reactions to post ${insertedPost.id}`);
          })());
        }
        
        console.log('Successfully created auto-generated AI post', insertedPost);
      } catch (dbError) {
        console.error('Database error during auto-generation:', dbError);
        // We'll still return the generated content even if DB operations fail
      }
    }
    
    return new Response(JSON.stringify({ content: generatedContent }), {
      headers: { ...corsHeaders, "Content-Type": "application/json" },
      status: 200,
    });
  } catch (error) {
    console.error("Error generating post:", error);
    return new Response(JSON.stringify({ error: error.message }), {
      headers: { ...corsHeaders, "Content-Type": "application/json" },
      status: 500,
    });
  }
});

// Create Supabase client function
async function createClient(supabaseUrl: string, supabaseKey: string) {
  const { createClient } = await import('https://esm.sh/@supabase/supabase-js@2.38.4');
  return createClient(supabaseUrl, supabaseKey);
}

// Helper functions for generating username
function generateRandomUsername(): string {
  const adjectives = ['cool', 'super', 'awesome', 'coding', 'dev', 'tech', 'data', 'web', 'pro', 'smart'];
  const nouns = ['coder', 'dev', 'builder', 'creator', 'ninja', 'guru', 'hacker', 'wizard', 'expert', 'geek'];
  
  if (Math.random() > 0.5) {
    const adj = adjectives[Math.floor(Math.random() * adjectives.length)];
    const noun = nouns[Math.floor(Math.random() * nouns.length)];
    const num = Math.floor(Math.random() * 1000);
    return `blue${adj}${noun}${num}`;
  } else {
    const randomNum = Math.floor(1000 + Math.random() * 90000).toString();
    return `blue${randomNum}`;
  }
}

// Add AI comments to a post
async function addAIComments(supabase: any, postId: string, postContent: string, blueUserId: string, commentCount: number) {
  try {
    // Try to use the generate-ai-comment function first
    try {
      const { data: aiData, error: aiError } = await fetch(
        `${Deno.env.get('SUPABASE_URL')}/functions/v1/generate-ai-comment`,
        {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ 
            postContent,
            commentsCount: commentCount
          })
        }
      ).then(res => res.json());
      
      if (aiError || !aiData?.comments || aiData.comments.length === 0) {
        throw new Error('No AI comments generated');
      }
      
      for (const commentData of aiData.comments) {
        await new Promise(resolve => setTimeout(resolve, Math.random() * 500));
        
        const { data: commentData_, error: commentError } = await supabase
          .from('comments')
          .insert({
            content: commentData.content,
            user_id: blueUserId,
            shoutout_id: postId,
            metadata: {
              display_username: commentData.displayUsername,
              is_ai_generated: true,
              reactions: commentData.reactions
            }
          })
          .select('*')
          .single();
          
        if (commentError) {
          console.error('Error adding AI comment:', commentError);
          continue;
        }
        
        await new Promise(resolve => setTimeout(resolve, 200));
        
        await addCommentReactions(supabase, commentData_.id, blueUserId, commentData.reactions);
      }
      
      return;
    } catch (aiGenError) {
      console.error('Error using AI comment generator:', aiGenError);
      // Fall back to manual comments
    }
    
    // Fallback comments
    const fallbackComments = [
      "Have you tried clearing your cache?",
      "I ran into this same issue last week. Try checking your console for errors.",
      "Maybe there's a syntax error somewhere?",
      "Works fine on my machine! 😅",
      "Have you checked the documentation?",
      "That's interesting. What version are you using?",
      "I'd recommend checking Stack Overflow for similar issues.",
      "Try updating to the latest version, it might be fixed already.",
      "Are all your dependencies up to date?",
      "Could be a browser compatibility issue. Which browser are you using?",
      "Did you try restarting your dev server?",
      "I think this is a known bug in the latest release.",
      "You might need to clear your browser cache and cookies.",
      "This seems like an environment variable problem to me.",
      "I had the same problem, turns out I misspelled a variable name!",
      "Check your network tab for any failed requests.",
      "Could be related to CORS settings on your server.",
      "Are you using the correct API endpoint?",
      "Double-check your authentication headers.",
      "Make sure your backend is actually running.",
      "I'd start by adding console logs to track the flow."
    ];
    
    const numberOfComments = Math.min(commentCount, fallbackComments.length);
    const selectedComments = [];
    
    for (let i = 0; i < numberOfComments; i++) {
      let comment;
      do {
        comment = fallbackComments[Math.floor(Math.random() * fallbackComments.length)];
      } while (selectedComments.includes(comment));
      
      selectedComments.push(comment);
      
      const displayUsername = generateRandomUsername();
      
      const randomEmojis = ['👍', '❤️', '🔥', '🚀', '🙌'].sort(() => Math.random() - 0.5).slice(0, Math.floor(Math.random() * 3) + 1);
      
      await new Promise(resolve => setTimeout(resolve, Math.random() * 300));
      
      const { data: commentData, error: commentError } = await supabase
        .from('comments')
        .insert({
          content: comment,
          user_id: blueUserId,
          shoutout_id: postId,
          metadata: {
            display_username: displayUsername,
            is_ai_generated: true,
            reactions: randomEmojis
          }
        })
        .select('*')
        .single();
        
      if (commentError) {
        console.error('Error adding fallback comment:', commentError);
        continue;
      }
      
      await new Promise(resolve => setTimeout(resolve, 200));
      
      await addCommentReactions(supabase, commentData.id, blueUserId, randomEmojis);
    }
  } catch (err) {
    console.error('Error adding comments:', err);
  }
}

// Add reactions to a comment
async function addCommentReactions(supabase: any, commentId: string, userId: string, emojis: string[]) {
  try {
    for (const emoji of emojis) {
      const reactionCount = Math.floor(Math.random() * 3) + 1;
      
      for (let i = 0; i < reactionCount; i++) {
        await supabase
          .from('comment_reactions')
          .insert({
            comment_id: commentId,
            user_id: userId,
            emoji: emoji
          });
          
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    }
  } catch (err) {
    console.error('Error adding comment reactions:', err);
  }
}

// Add emoji reactions to a post
async function addRandomEmojiReactions(supabase: any, postId: string, userId: string) {
  try {
    const emojiOptions = ['👍', '❤️', '🔥', '👏', '😄', '🚀', '💯', '🙌', '👌', '😎'];
    
    const numberOfReactions = Math.floor(Math.random() * 23) + 7;
    const selectedEmojis = [];
    
    for (let i = 0; i < numberOfReactions; i++) {
      let emoji;
      do {
        emoji = emojiOptions[Math.floor(Math.random() * emojiOptions.length)];
      } while (selectedEmojis.includes(emoji));
      
      selectedEmojis.push(emoji);
      
      const reactionCount = Math.floor(Math.random() * 3) + 1;
      
      for (let j = 0; j < reactionCount; j++) {
        await supabase
          .from('post_reactions')
          .insert({
            post_id: String(postId),
            user_id: userId,
            emoji: emoji
          });
          
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    }
  } catch (err) {
    console.error('Error adding emoji reactions:', err);
  }
}
